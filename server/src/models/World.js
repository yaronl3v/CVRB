import { DataTypes } from 'sequelize';
import db from '../db.js';

const sequelize = db.getSequelize();

const World = sequelize.define('World', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  creator: {
    type: DataTypes.STRING,
    allowNull: false,
    comment: 'Model name from ModelApiNames that created this CVRB'
  },
  is_valid: {
    type: DataTypes.BOOLEAN,
    defaultValue: null,
    comment: 'Whether this CVRB passed validation tests'
  },
  validation_notes: {
    type: DataTypes.JSONB,
    defaultValue: {},
    comment: 'JSON containing validation results and notes'
  },
  world_info: {
    type: DataTypes.JSONB,
    allowNull: false,
    comment: 'JSON with CVRB data: questions, answers, description, spec, etc.'
  },
  world_code: {
    type: DataTypes.TEXT,
    allowNull: false,
    comment: 'The JavaScript simulation code for this CVRB'
  },
  validation_code: {
    type: DataTypes.JSONB,
    defaultValue: [],
    comment: 'Array of validation code strings generated by validator models'
  },
  world_name: {
    type: DataTypes.STRING,
    allowNull: true,
    comment: 'The name of the CVRB from the LLM response'
  },
  set: {
    type: DataTypes.INTEGER,
    defaultValue: 0,
    allowNull: false,
    comment: 'Set identifier for grouping worlds, default value is 0'
  },
  quality_score: {
    type: DataTypes.FLOAT,
    defaultValue: 0.0,
    allowNull: false,
    comment: 'Quality score for the CVRB as a float, default value is 0.0'
  }
}, {
  tableName: 'worlds',
  timestamps: true // Adds createdAt and updatedAt
});

// Model helper functions
export const WorldHelpers = {
  /**
   * Create a new CVRB record
   */
  async createWorld(worldData) {
    try {
      const world = await World.create({
        creator: worldData.creator,
        is_valid: worldData.is_valid || null,
        validation_notes: worldData.validation_notes || {},
        world_info: worldData.world_info,
        world_code: worldData.world_code,
        validation_code: worldData.validation_code || [],
        world_name: worldData.world_name || null,
        set: worldData.set || 0,
        quality_score: worldData.quality_score || 0.0
      });
      
      return world.dataValues;
    } catch (error) {
      console.error('Error creating CVRB:', error);
      throw error;
    }
  },

  /**
   * Update validation status and notes for a CVRB
   */
  async updateValidation(worldId, isValid, validationNotes) {
    try {
      const [updatedRowsCount] = await World.update(
        {
          is_valid: isValid,
          validation_notes: validationNotes
        },
        {
          where: { id: worldId }
        }
      );
      
      if (updatedRowsCount === 0) {
        throw new Error(`World with id ${worldId} not found`);
      }
      
      const updatedWorld = await World.findByPk(worldId);
      return updatedWorld.dataValues;
    } catch (error) {
      console.error('Error updating CVRB validation:', error);
      throw error;
    }
  },

  /**
   * Get CVRB by ID
   */
  async getWorldById(worldId) {
    try {
      const world = await World.findByPk(worldId);
      return world ? world.dataValues : null;
    } catch (error) {
      console.error('Error getting CVRB by ID:', error);
      throw error;
    }
  },

  /**
   * Get worlds by creator
   */
  async getWorldsByCreator(creator) {
    try {
      const worlds = await World.findAll({
        where: { creator },
        order: [['createdAt', 'DESC']]
      });
      
      return worlds.map(world => world.dataValues);
    } catch (error) {
      console.error('Error getting worlds by creator:', error);
      throw error;
    }
  },

  /**
   * Get all valid worlds
   */
  async getValidWorlds() {
    try {
      const worlds = await World.findAll({
        where: { is_valid: true },
        order: [['createdAt', 'DESC']]
      });
      
      return worlds.map(world => world.dataValues);
    } catch (error) {
      console.error('Error getting valid worlds:', error);
      throw error;
    }
  },

  /**
   * Get recent worlds with optional limit
   */
  async getRecentWorlds(limit = 10) {
    try {
      const worlds = await World.findAll({
        order: [['createdAt', 'DESC']],
        limit
      });
      
      return worlds.map(world => world.dataValues);
    } catch (error) {
      console.error('Error getting recent worlds:', error);
      throw error;
    }
  },

  /**
   * Get worlds by set
   */
  async getWorldsBySet(setNumber) {
    try {
      const worlds = await World.findAll({
        where: { set: setNumber },
        order: [['createdAt', 'DESC']]
      });
      
      return worlds.map(world => world.dataValues);
    } catch (error) {
      console.error('Error getting worlds by set:', error);
      throw error;
    }
  },

  /**
   * Get only the IDs of worlds by set (lightweight)
   */
  async getWorldIdsBySet(setNumber) {
    try {
      const worlds = await World.findAll({
        attributes: ['id'],
        where: { set: setNumber },
        order: [['createdAt', 'DESC']]
      });
      return worlds.map(w => w.dataValues.id);
    } catch (error) {
      console.error('Error getting world IDs by set:', error);
      throw error;
    }
  },

  /**
   * Get IDs of all worlds (lightweight)
   */
  async getAllWorldIds() {
    try {
      const worlds = await World.findAll({ attributes: ['id'], order: [['createdAt', 'DESC']] });
      return worlds.map(w => w.dataValues.id);
    } catch (error) {
      console.error('Error getting all world IDs:', error);
      throw error;
    }
  },

  /**
   * Delete CVRB by ID (will cascade delete all solutions)
   */
  async deleteWorld(worldId) {
    try {
      const deletedRowsCount = await World.destroy({
        where: { id: worldId }
      });
      
      if (deletedRowsCount === 0) {
        throw new Error(`World with id ${worldId} not found`);
      }
      
      return { success: true, deletedRows: deletedRowsCount };
    } catch (error) {
      console.error('Error deleting CVRB:', error);
      throw error;
    }
  },

  /**
   * Update CVRB set number
   */
  async updateWorldSet(worldId, setNumber) {
    try {
      const [updatedRowsCount] = await World.update(
        { set: setNumber },
        { where: { id: worldId } }
      );
      
      if (updatedRowsCount === 0) {
        throw new Error(`World with id ${worldId} not found`);
      }
      
      const updatedWorld = await World.findByPk(worldId);
      return updatedWorld.dataValues;
    } catch (error) {
      console.error('Error updating CVRB set:', error);
      throw error;
    }
  },

  /**
   * Update CVRB quality score
   */
  async updateQualityScore(worldId, qualityScore) {
    try {
      const [updatedRowsCount] = await World.update(
        { quality_score: qualityScore },
        { where: { id: worldId } }
      );
      
      if (updatedRowsCount === 0) {
        throw new Error(`World with id ${worldId} not found`);
      }
      
      const updatedWorld = await World.findByPk(worldId);
      return updatedWorld.dataValues;
    } catch (error) {
      console.error('Error updating CVRB quality score:', error);
      throw error;
    }
  }
};

export default World;